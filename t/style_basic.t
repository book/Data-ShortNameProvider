use strict;
use warnings;
use Test::More;

use Data::ShortNameProvider;

my %args = ( max_name_length => 32 );

# style failure cases
ok( !eval { Data::ShortNameProvider->new( %args, style => 'not_a_style' ) },
    'Failed to load style class' );
like(
    $@,
    qr{^Can't locate Data/ShortNameProvider/Style/not_a_style\.pm },
    '... expected error message'
);

ok( !eval { Data::ShortNameProvider->new( %args, style => '+Test::More' ) },
    'Bad style class' );
like(
    $@,
    qr/^Test::More does not implement the Data::ShortNameProvider::Role::Style role /,
    '... expected error message'
);

# test the same style in different ways
for my $style (qw( Basic +Data::ShortNameProvider::Style::Basic )) {

    my $v = int rand 20;
    my $l = 20 + int rand 20;
    my $n = join '', map chr( 65 + rand 26 ), 0 .. rand 5;
    %args = (
        style           => $style,
        max_name_length => $l,
        timestamp_epoch => 1234567890,    # Fri Feb 13 23:31:30 2009

        # Basic-specific arguments
        prefix  => 'dbit',
        version => $v,
    );

    # failing tests
    ok( !eval { Data::ShortNameProvider->new( %args, version => 'a' ) },
        'non-numeric version' );
    like(
        $@,
        qr/^isa check for "version" failed: 'a' is not a integer /,
        '... expected error message'
    );

    # passing tests
    my $np = Data::ShortNameProvider->new( %args );

    # type checking
    isa_ok( $np,           'Data::ShortNameProvider' );
    isa_ok( $np->provider, 'Data::ShortNameProvider::Style::Basic' );
    is( $np->style_class, 'Data::ShortNameProvider::Style::Basic',
        'style_class' );

    # delegated stuff
    is( $np->timestamp_epoch,           1234567890, 'timestamp_epoch (main)' );
    is( $np->provider->timestamp_epoch, 1234567890, 'timestamp_epoch (style)' );

    # short names
    my $sn = $np->generate_new_name($n);
    is( $sn, "dbit${v}_090213__$n", "'$sn' is a short name for '$n'" );

    ok( $np->is_generated_name($sn),   "'$sn' was generated by us" );
    ok( !$np->is_generated_name('foo'), "'foo' was NOT generated by us" );

    # parse names
    diag $np->provider->parsing_regexp;

    # via the provider
    my $hash = $np->provider->parse_generated_name($sn);
    is_deeply(
        $hash,
        {
            prefix          => 'dbit',
            version         => $v,
            timestamp       => '090213',
            timestamp_epoch => 1234567890,
            name            => $n,
        },
        "parsed '$sn' (style)"
    );
    is( $np->style_class->new($hash)->generate_new_name('bar'),
        "dbit${v}_090213__bar", "generate a short name for 'bar' (style)" );

    # via the main class delegation
    $hash = $np->parse_generated_name($sn);
    is_deeply(
        $hash,
        {
            style           => $style,
            max_name_length => $l,
            prefix          => 'dbit',
            version         => $v,
            timestamp       => '090213',
            timestamp_epoch => 1234567890,
            name            => $n,
        },
        "parsed '$sn' (main)"
    );
    is(
        Data::ShortNameProvider->new($hash)->generate_new_name('bar'),
        "dbit${v}_090213__bar",
        "generate a short name for 'bar' (main)"
    );

    # error case
    $n = join '', map chr( 65 + rand 26 ), 1 .. 40;
    ok( !eval { $np->generate_new_name($n) }, "$n too long" );
    like(
        $@,
        qr/^dbit${v}_090213__$n \(provided by Data::ShortNameProvider::Style::Basic\) is longer than the $l characters limit /,
        '... expected error message'
    );

}

done_testing;
